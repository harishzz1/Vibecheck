#!/usr/bin/env python3
"""
Advanced Multi-Language Vulnerability Scanner
Detects security vulnerabilities across different programming languages and frameworks
"""

import os
import re
import json
import hashlib
import base64
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from enum import Enum
import argparse
import sys

class VulnerabilityType(Enum):
    SQL_INJECTION = "SQL Injection"
    XSS = "Cross-Site Scripting (XSS)"
    HARDCODED_SECRET = "Hardcoded Secret"
    WEAK_CRYPTO = "Weak Cryptography"
    INSECURE_RANDOM = "Insecure Random"
    PATH_TRAVERSAL = "Path Traversal"
    COMMAND_INJECTION = "Command Injection"
    LDAP_INJECTION = "LDAP Injection"
    XXE = "XML External Entity (XXE)"
    CSRF = "Cross-Site Request Forgery"
    INSECURE_DESERIALIZATION = "Insecure Deserialization"
    BUFFER_OVERFLOW = "Buffer Overflow"
    INTEGER_OVERFLOW = "Integer Overflow"
    NULL_POINTER = "Null Pointer Dereference"
    RACE_CONDITION = "Race Condition"
    PRIVILEGE_ESCALATION = "Privilege Escalation"
    INFORMATION_DISCLOSURE = "Information Disclosure"
    BROKEN_AUTH = "Broken Authentication"
    INSECURE_STORAGE = "Insecure Storage"
    WEAK_SESSION = "Weak Session Management"

class Severity(Enum):
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Info"

@dataclass
class Vulnerability:
    type: VulnerabilityType
    severity: Severity
    file_path: str
    line_number: int
    code_snippet: str
    description: str
    recommendation: str
    cwe_id: Optional[str] = None

class VulnerabilityScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.scanned_files = 0
        self.excluded_dirs = {
            'node_modules', '.git', '.next', 'dist', 'build', '.nuxt', 
            '.vscode', '.idea', 'coverage', '__pycache__', '.pytest_cache',
            'vendor', 'target', 'bin', 'obj', '.gradle', 'venv', 'env'
        }
        self.excluded_extensions = {
            '.log', '.tmp', '.cache', '.lock', '.pyc', '.pyo', '.class',
            '.jar', '.war', '.ear', '.zip', '.tar', '.gz', '.exe', '.dll'
        }
        
        # Initialize vulnerability patterns
        self._init_vulnerability_patterns()
    
    def reset(self):
        """Reset scanner state for new scan"""
        self.vulnerabilities = []
        self.scanned_files = 0
    
    def _init_vulnerability_patterns(self):
        """Initialize regex patterns for vulnerability detection"""
        
        # SQL Injection patterns for multiple languages
        self.sql_injection_patterns = [
            # String concatenation in SQL queries
            (r'(?:SELECT|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER)\s+.*?\+.*?["\']', VulnerabilityType.SQL_INJECTION),
            (r'["\'].*?\+.*?(?:SELECT|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER)', VulnerabilityType.SQL_INJECTION),
            
            # Format string vulnerabilities
            (r'(?:SELECT|INSERT|UPDATE|DELETE)\s+.*?%s.*?%', VulnerabilityType.SQL_INJECTION),
            (r'(?:SELECT|INSERT|UPDATE|DELETE)\s+.*?\{.*?\}', VulnerabilityType.SQL_INJECTION),
            
            # Direct variable interpolation
            (r'(?:SELECT|INSERT|UPDATE|DELETE)\s+.*?\$\{.*?\}', VulnerabilityType.SQL_INJECTION),
            (r'(?:SELECT|INSERT|UPDATE|DELETE)\s+.*?f["\'].*?\{.*?\}', VulnerabilityType.SQL_INJECTION),
            
            # Unsafe query building
            (r'query\s*=\s*["\'].*?\+.*?["\']', VulnerabilityType.SQL_INJECTION),
            (r'sql\s*=\s*["\'].*?\+.*?["\']', VulnerabilityType.SQL_INJECTION),
        ]
        
        # XSS patterns
        self.xss_patterns = [
            # innerHTML assignments
            (r'\.innerHTML\s*=\s*.*?\+.*?', VulnerabilityType.XSS),
            (r'\.innerHTML\s*=\s*["\'].*?\$\{.*?\}', VulnerabilityType.XSS),
            
            # Document write
            (r'document\.write\s*\(.*?\+.*?\)', VulnerabilityType.XSS),
            (r'document\.writeln\s*\(.*?\+.*?\)', VulnerabilityType.XSS),
            
            # Unsafe HTML generation
            (r'<.*?\$\{.*?\}.*?>', VulnerabilityType.XSS),
            (r'<.*?\+.*?\+.*?>', VulnerabilityType.XSS),
            
            # Template vulnerabilities
            (r'\{\{\s*.*?\|\s*safe\s*\}\}', VulnerabilityType.XSS),
            (r'<%=.*?%>', VulnerabilityType.XSS),
        ]
        
        # Hardcoded secrets patterns
        self.secret_patterns = [
            # API Keys
            (r'(?:api_key|apikey|api-key)\s*[=:]\s*["\'][a-zA-Z0-9]{20,}["\']', VulnerabilityType.HARDCODED_SECRET),
            (r'(?:secret_key|secretkey|secret-key)\s*[=:]\s*["\'][a-zA-Z0-9]{20,}["\']', VulnerabilityType.HARDCODED_SECRET),
            
            # Database passwords
            (r'(?:password|passwd|pwd)\s*[=:]\s*["\'][^"\']{6,}["\']', VulnerabilityType.HARDCODED_SECRET),
            (r'(?:db_pass|database_password)\s*[=:]\s*["\'][^"\']+["\']', VulnerabilityType.HARDCODED_SECRET),
            
            # JWT secrets
            (r'(?:jwt_secret|jwt_key)\s*[=:]\s*["\'][a-zA-Z0-9]{20,}["\']', VulnerabilityType.HARDCODED_SECRET),
            
            # Private keys
            (r'-----BEGIN\s+(?:RSA\s+)?PRIVATE\s+KEY-----', VulnerabilityType.HARDCODED_SECRET),
            
            # AWS keys
            (r'AKIA[0-9A-Z]{16}', VulnerabilityType.HARDCODED_SECRET),
            
            # Generic secrets
            (r'["\'][a-zA-Z0-9]{32,}["\']', VulnerabilityType.HARDCODED_SECRET),
        ]
        
        # Weak cryptography patterns
        self.crypto_patterns = [
            # Weak hash algorithms
            (r'(?:md5|sha1)\s*\(', VulnerabilityType.WEAK_CRYPTO),
            (r'hashlib\.(?:md5|sha1)\s*\(', VulnerabilityType.WEAK_CRYPTO),
            (r'MessageDigest\.getInstance\s*\(\s*["\'](?:MD5|SHA1)["\']', VulnerabilityType.WEAK_CRYPTO),
            
            # Weak encryption
            (r'DES\s*\(', VulnerabilityType.WEAK_CRYPTO),
            (r'Cipher\.getInstance\s*\(\s*["\']DES', VulnerabilityType.WEAK_CRYPTO),
            
            # Insecure random
            (r'Math\.random\s*\(\s*\)', VulnerabilityType.INSECURE_RANDOM),
            (r'Random\s*\(\s*\)', VulnerabilityType.INSECURE_RANDOM),
        ]
        
        # Path traversal patterns
        self.path_traversal_patterns = [
            (r'\.\./', VulnerabilityType.PATH_TRAVERSAL),
            (r'\.\.\\', VulnerabilityType.PATH_TRAVERSAL),
            (r'path.*?\+.*?request', VulnerabilityType.PATH_TRAVERSAL),
            (r'File\s*\(.*?\+.*?\)', VulnerabilityType.PATH_TRAVERSAL),
        ]
        
        # Command injection patterns
        self.command_injection_patterns = [
            (r'exec\s*\(.*?\+.*?\)', VulnerabilityType.COMMAND_INJECTION),
            (r'system\s*\(.*?\+.*?\)', VulnerabilityType.COMMAND_INJECTION),
            (r'popen\s*\(.*?\+.*?\)', VulnerabilityType.COMMAND_INJECTION),
            (r'subprocess\..*?\(.*?\+.*?\)', VulnerabilityType.COMMAND_INJECTION),
            (r'Runtime\.getRuntime\s*\(\s*\)\.exec\s*\(.*?\+.*?\)', VulnerabilityType.COMMAND_INJECTION),
        ]
        
        # XXE patterns
        self.xxe_patterns = [
            (r'DocumentBuilderFactory.*?setFeature.*?false', VulnerabilityType.XXE),
            (r'XMLInputFactory.*?setProperty.*?false', VulnerabilityType.XXE),
            (r'<!ENTITY.*?SYSTEM', VulnerabilityType.XXE),
        ]
        
        # CSRF patterns
        self.csrf_patterns = [
            (r'@csrf_exempt', VulnerabilityType.CSRF),
            (r'csrf:\s*false', VulnerabilityType.CSRF),
            (r'csrfToken.*?false', VulnerabilityType.CSRF),
        ]
    
    def scan_directory(self, directory_path: str) -> List[Vulnerability]:
        """Scan entire directory for vulnerabilities"""
        directory = Path(directory_path)
        if not directory.exists():
            print(f"Error: Directory {directory_path} does not exist")
            return []
        
        print(f"ðŸ” Starting vulnerability scan of: {directory_path}")
        print("-" * 60)
        
        for file_path in directory.rglob('*'):
            if self._should_scan_file(file_path):
                self._scan_file(file_path)
        
        print(f"\nðŸ“Š Scan Summary:")
        print(f"Files scanned: {self.scanned_files}")
        print(f"Vulnerabilities found: {len(self.vulnerabilities)}")
        
        return self.vulnerabilities
    
    def _should_scan_file(self, file_path: Path) -> bool:
        """Check if file should be scanned"""
        # Skip directories
        if file_path.is_dir():
            return False
        
        # Skip excluded directories
        for part in file_path.parts:
            if part in self.excluded_dirs:
                return False
        
        # Skip excluded extensions
        if file_path.suffix.lower() in self.excluded_extensions:
            return False
        
        # Skip binary files
        try:
            with open(file_path, 'rb') as f:
                chunk = f.read(1024)
                if b'\x00' in chunk:  # Contains null bytes, likely binary
                    return False
        except (IOError, OSError):
            return False
        
        return True
    
    def _scan_file(self, file_path: Path) -> None:
        """Scan individual file for vulnerabilities"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                lines = content.split('\n')
                
                self.scanned_files += 1
                print(f"Scanning: {file_path}")
                
                # Scan each line
                for line_num, line in enumerate(lines, 1):
                    self._scan_line(str(file_path), line_num, line, content)
                    
        except (IOError, OSError, UnicodeDecodeError) as e:
            print(f"Warning: Could not scan {file_path}: {e}")
    
    def _scan_line(self, file_path: str, line_num: int, line: str, full_content: str) -> None:
        """Scan individual line for vulnerabilities"""
        line_lower = line.lower().strip()
        
        # Skip comments and empty lines
        if not line_lower or line_lower.startswith(('#', '//', '/*', '*', '--')):
            return
        
        # Check all vulnerability patterns
        self._check_sql_injection(file_path, line_num, line)
        self._check_xss(file_path, line_num, line)
        self._check_hardcoded_secrets(file_path, line_num, line)
        self._check_weak_crypto(file_path, line_num, line)
        self._check_path_traversal(file_path, line_num, line)
        self._check_command_injection(file_path, line_num, line)
        self._check_xxe(file_path, line_num, line)
        self._check_csrf(file_path, line_num, line)
        self._check_additional_vulnerabilities(file_path, line_num, line)
    
    def _check_sql_injection(self, file_path: str, line_num: int, line: str) -> None:
        """Check for SQL injection vulnerabilities"""
        for pattern, vuln_type in self.sql_injection_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                severity = Severity.CRITICAL if 'delete' in line.lower() or 'drop' in line.lower() else Severity.HIGH
                
                self.vulnerabilities.append(Vulnerability(
                    type=vuln_type,
                    severity=severity,
                    file_path=file_path,
                    line_number=line_num,
                    code_snippet=line.strip(),
                    description="SQL injection vulnerability detected. User input appears to be directly concatenated into SQL query.",
                    recommendation="Use parameterized queries or prepared statements. Never concatenate user input directly into SQL queries.",
                    cwe_id="CWE-89"
                ))
                break
    
    def _check_xss(self, file_path: str, line_num: int, line: str) -> None:
        """Check for XSS vulnerabilities"""
        for pattern, vuln_type in self.xss_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                self.vulnerabilities.append(Vulnerability(
                    type=vuln_type,
                    severity=Severity.HIGH,
                    file_path=file_path,
                    line_number=line_num,
                    code_snippet=line.strip(),
                    description="Cross-Site Scripting (XSS) vulnerability detected. User input may be rendered without proper sanitization.",
                    recommendation="Sanitize all user input before rendering. Use textContent instead of innerHTML, or use a trusted sanitization library.",
                    cwe_id="CWE-79"
                ))
                break
    
    def _check_hardcoded_secrets(self, file_path: str, line_num: int, line: str) -> None:
        """Check for hardcoded secrets"""
        for pattern, vuln_type in self.secret_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                # Skip obvious test/example values
                if any(test_val in line.lower() for test_val in ['test', 'example', 'demo', 'placeholder', 'your_key_here']):
                    continue
                
                self.vulnerabilities.append(Vulnerability(
                    type=vuln_type,
                    severity=Severity.HIGH,
                    file_path=file_path,
                    line_number=line_num,
                    code_snippet=line.strip(),
                    description="Hardcoded secret detected. Sensitive information should not be stored in source code.",
                    recommendation="Move secrets to environment variables or a secure configuration management system.",
                    cwe_id="CWE-798"
                ))
                break
    
    def _check_weak_crypto(self, file_path: str, line_num: int, line: str) -> None:
        """Check for weak cryptographic implementations"""
        for pattern, vuln_type in self.crypto_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                severity = Severity.HIGH if vuln_type == VulnerabilityType.WEAK_CRYPTO else Severity.MEDIUM
                
                description = "Weak cryptographic algorithm detected."
                recommendation = "Use strong cryptographic algorithms like SHA-256, SHA-3, or bcrypt for hashing."
                
                if vuln_type == VulnerabilityType.INSECURE_RANDOM:
                    description = "Insecure random number generation detected."
                    recommendation = "Use cryptographically secure random number generators (e.g., secrets module in Python, crypto.randomBytes in Node.js)."
                
                self.vulnerabilities.append(Vulnerability(
                    type=vuln_type,
                    severity=severity,
                    file_path=file_path,
                    line_number=line_num,
                    code_snippet=line.strip(),
                    description=description,
                    recommendation=recommendation,
                    cwe_id="CWE-327"
                ))
                break
    
    def _check_path_traversal(self, file_path: str, line_num: int, line: str) -> None:
        """Check for path traversal vulnerabilities"""
        for pattern, vuln_type in self.path_traversal_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                self.vulnerabilities.append(Vulnerability(
                    type=vuln_type,
                    severity=Severity.HIGH,
                    file_path=file_path,
                    line_number=line_num,
                    code_snippet=line.strip(),
                    description="Path traversal vulnerability detected. User input may be used to access unauthorized files.",
                    recommendation="Validate and sanitize file paths. Use allowlists for permitted paths and resolve symbolic links.",
                    cwe_id="CWE-22"
                ))
                break
    
    def _check_command_injection(self, file_path: str, line_num: int, line: str) -> None:
        """Check for command injection vulnerabilities"""
        for pattern, vuln_type in self.command_injection_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                self.vulnerabilities.append(Vulnerability(
                    type=vuln_type,
                    severity=Severity.CRITICAL,
                    file_path=file_path,
                    line_number=line_num,
                    code_snippet=line.strip(),
                    description="Command injection vulnerability detected. User input may be executed as system commands.",
                    recommendation="Never pass user input directly to system commands. Use parameterized commands or validate input strictly.",
                    cwe_id="CWE-78"
                ))
                break
    
    def _check_xxe(self, file_path: str, line_num: int, line: str) -> None:
        """Check for XXE vulnerabilities"""
        for pattern, vuln_type in self.xxe_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                self.vulnerabilities.append(Vulnerability(
                    type=vuln_type,
                    severity=Severity.HIGH,
                    file_path=file_path,
                    line_number=line_num,
                    code_snippet=line.strip(),
                    description="XML External Entity (XXE) vulnerability detected. XML parser may be configured insecurely.",
                    recommendation="Disable external entity processing in XML parsers. Use secure XML parsing libraries.",
                    cwe_id="CWE-611"
                ))
                break
    
    def _check_csrf(self, file_path: str, line_num: int, line: str) -> None:
        """Check for CSRF vulnerabilities"""
        for pattern, vuln_type in self.csrf_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                self.vulnerabilities.append(Vulnerability(
                    type=vuln_type,
                    severity=Severity.MEDIUM,
                    file_path=file_path,
                    line_number=line_num,
                    code_snippet=line.strip(),
                    description="CSRF protection disabled or missing. Application may be vulnerable to cross-site request forgery.",
                    recommendation="Enable CSRF protection and use anti-CSRF tokens for state-changing operations.",
                    cwe_id="CWE-352"
                ))
                break
    
    def _check_additional_vulnerabilities(self, file_path: str, line_num: int, line: str) -> None:
        """Check for additional vulnerability patterns"""
        line_lower = line.lower()
        
        # Insecure HTTP usage
        if re.search(r'http://(?!localhost|127\.0\.0\.1)', line_lower):
            self.vulnerabilities.append(Vulnerability(
                type=VulnerabilityType.INFORMATION_DISCLOSURE,
                severity=Severity.MEDIUM,
                file_path=file_path,
                line_number=line_num,
                code_snippet=line.strip(),
                description="Insecure HTTP protocol usage detected. Data may be transmitted in plaintext.",
                recommendation="Use HTTPS instead of HTTP for all external communications.",
                cwe_id="CWE-319"
            ))
        
        # Insecure session configuration
        if re.search(r'session.*?secure.*?false', line_lower):
            self.vulnerabilities.append(Vulnerability(
                type=VulnerabilityType.WEAK_SESSION,
                severity=Severity.MEDIUM,
                file_path=file_path,
                line_number=line_num,
                code_snippet=line.strip(),
                description="Insecure session configuration detected. Session cookies may not be secure.",
                recommendation="Set secure flag on session cookies and use HttpOnly attribute.",
                cwe_id="CWE-614"
            ))
        
        # Debugging information disclosure
        if re.search(r'(?:debug|trace)\s*[=:]\s*true', line_lower):
            self.vulnerabilities.append(Vulnerability(
                type=VulnerabilityType.INFORMATION_DISCLOSURE,
                severity=Severity.LOW,
                file_path=file_path,
                line_number=line_num,
                code_snippet=line.strip(),
                description="Debug mode enabled. This may expose sensitive information.",
                recommendation="Disable debug mode in production environments.",
                cwe_id="CWE-489"
            ))
    
    def generate_report(self, format_type: str = 'console') -> str:
        """Generate vulnerability report"""
        if format_type == 'json':
            return self._generate_json_report()
        else:
            return self._generate_console_report()
    
    def _generate_console_report(self) -> str:
        """Generate console-formatted report"""
        if not self.vulnerabilities:
            return "âœ… No vulnerabilities found!"
        
        # Group by severity
        severity_groups = {}
        for vuln in self.vulnerabilities:
            if vuln.severity not in severity_groups:
                severity_groups[vuln.severity] = []
            severity_groups[vuln.severity].append(vuln)
        
        report = "\n" + "="*80 + "\n"
        report += "ðŸš¨ VULNERABILITY SCAN REPORT\n"
        report += "="*80 + "\n\n"
        
        # Summary
        report += f"ðŸ“Š SUMMARY:\n"
        report += f"Total vulnerabilities: {len(self.vulnerabilities)}\n"
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW]:
            count = len(severity_groups.get(severity, []))
            if count > 0:
                report += f"{severity.value}: {count}\n"
        
        report += "\n" + "-"*80 + "\n\n"
        
        # Detailed findings
        vuln_counter = 1
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW]:
            if severity not in severity_groups:
                continue
            
            for vuln in severity_groups[severity]:
                severity_emoji = {
                    Severity.CRITICAL: "ðŸ”´",
                    Severity.HIGH: "ðŸŸ ", 
                    Severity.MEDIUM: "ðŸŸ¡",
                    Severity.LOW: "ðŸ”µ"
                }.get(severity, "âšª")
                
                report += f"{severity_emoji} VULNERABILITY #{vuln_counter}\n"
                report += f"Type: {vuln.type.value}\n"
                report += f"Severity: {vuln.severity.value}\n"
                report += f"File: {vuln.file_path}:{vuln.line_number}\n"
                if vuln.cwe_id:
                    report += f"CWE: {vuln.cwe_id}\n"
                report += f"Code: {vuln.code_snippet}\n"
                report += f"Description: {vuln.description}\n"
                report += f"Recommendation: {vuln.recommendation}\n"
                report += "-"*40 + "\n\n"
                vuln_counter += 1
        
        return report
    
    def _generate_json_report(self) -> str:
        """Generate JSON-formatted report"""
        vulnerabilities_dict = []
        for vuln in self.vulnerabilities:
            vulnerabilities_dict.append({
                'type': vuln.type.value,
                'severity': vuln.severity.value,
                'file_path': vuln.file_path,
                'line_number': vuln.line_number,
                'code_snippet': vuln.code_snippet,
                'description': vuln.description,
                'recommendation': vuln.recommendation,
                'cwe_id': vuln.cwe_id
            })
        
        report = {
            'scan_summary': {
                'total_vulnerabilities': len(self.vulnerabilities),
                'files_scanned': self.scanned_files,
                'severity_breakdown': {
                    'critical': len([v for v in self.vulnerabilities if v.severity == Severity.CRITICAL]),
                    'high': len([v for v in self.vulnerabilities if v.severity == Severity.HIGH]),
                    'medium': len([v for v in self.vulnerabilities if v.severity == Severity.MEDIUM]),
                    'low': len([v for v in self.vulnerabilities if v.severity == Severity.LOW])
                }
            },
            'vulnerabilities': vulnerabilities_dict
        }
        
        return json.dumps(report, indent=2)

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description='Advanced Multi-Language Vulnerability Scanner')
    parser.add_argument('directory', nargs='?', default='.', help='Directory to scan for vulnerabilities (default: current directory)')
    parser.add_argument('--format', choices=['console', 'json'], default='console', 
                       help='Output format (default: console)')
    parser.add_argument('--output', '-o', help='Output file (default: stdout)')
    
    args = parser.parse_args()
    
    # Create scanner and run scan
    scanner = VulnerabilityScanner()
    vulnerabilities = scanner.scan_directory(args.directory)
    
    # Generate report
    report = scanner.generate_report(args.format)
    
    # Output report
    if args.output:
        with open(args.output, 'w') as f:
            f.write(report)
        print(f"Report saved to: {args.output}")
    else:
        print(report)
    
    # Exit with appropriate code
    if vulnerabilities:
        sy
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        s.exit(1)  # Vulnerabilities found
    else:
        sys.exit(0)  # No vulnerabilities

if __name__ == '__main__':
    main()